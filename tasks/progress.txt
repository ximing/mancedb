## Codebase Patterns
- TypeDI Dependency Injection: Import 'reflect-metadata' at the top of main entry file before any other imports
- TypeDI Service Registration: Use dynamic imports in initContainer() to trigger @Service() decorators
- Electron Main Process DI: Initialize container in app.whenReady() before registering IPC handlers
- Electron Native Modules: Add native dependencies like @lancedb/lancedb to rollup external in vite.config.ts
- TypeScript Decorators: Enable experimentalDecorators and emitDecoratorMetadata in tsconfig for TypeDI
- IPC Router DI Pattern: Use Container.get(ServiceClass) in a helper function to retrieve services

---

## 2026-02-16 19:00 - US-013
- Completed as part of US-012 implementation
- Updated ipc-router.ts to use DI container:
  - Added getLanceDBService() helper that calls Container.get(LanceDBService)
  - All route handlers now get service instance via getLanceDBService()
  - IPC handlers (db:connect, db:disconnect, db:test) also use the DI container
- All IPC endpoints maintain the same response format for backward compatibility
- Renderer to main process communication works correctly through the DI service
- Typecheck passes, build passes

**Learnings for future iterations:**
- Using a helper function like getLanceDBService() makes it easy to switch between DI and direct instantiation
- The IPC router pattern separates routing logic from service implementation
- All service methods should return plain objects suitable for IPC serialization
---

## 2026-02-16 18:30 - US-012
- Removed vectordb dependency from apps/client
- Added @lancedb/lancedb ^0.26.2, @mancedb/lancedb-core, and @mancedb/dto dependencies
- Refactored apps/client/src/main/services/lancedb.service.ts:
  - Converted from module-level functions to TypeDI @Service() class
  - Injected ConnectionManager, TableManager, QueryEngine, SchemaManager via constructor
  - Maintained same public API for backward compatibility with ipc-router.ts
  - Updated all type imports to use @mancedb/dto
- Updated apps/client/src/main/ipc-router.ts:
  - Added getLanceDBService() helper that uses Container.get(LanceDBService)
  - All IPC handlers now get service instance from DI container
- Updated apps/client/src/main/container.ts:
  - Added import '@mancedb/lancedb-core' to ensure core services are registered
- Updated apps/client/tsconfig.main.json:
  - Enabled experimentalDecorators and emitDecoratorMetadata for TypeDI
- Updated apps/client/vite.config.ts:
  - Added @lancedb/lancedb, @mancedb/lancedb-core, @mancedb/dto, typedi, reflect-metadata to external deps
  - Prevents bundling of native modules and workspace packages
- Fixed pre-existing type errors in apps/web/src/pages/startup/startup-mode.tsx and electron.d.ts
- Typecheck passes, build passes, lint passes

**Learnings for future iterations:**
- Native Node.js modules (like LanceDB) must be added to rollupOptions.external in vite.config.ts
- When using TypeDI with decorators, both experimentalDecorators and emitDecoratorMetadata must be enabled
- Workspace packages should be external in Electron builds to avoid bundling issues
- The DI container pattern allows easy service mocking for testing
- Importing the entire lancedb-core module ensures all @Service() decorators are executed
---

## 2026-02-16 16:45 - US-011
- Added typedi (^0.10.0) and reflect-metadata (^0.2.2) dependencies to apps/client
- Created apps/client/src/main/container.ts with TypeDI Container configuration
  - initContainer() function dynamically imports all service files to register @Service() decorators
  - getService() helper for retrieving service instances from container
  - Re-exports Container from typedi for direct access
- Updated apps/client/src/main/index.ts:
  - Added 'import "reflect-metadata"' at the very top (required for TypeDI)
  - Imported initContainer from './container'
  - Made app.whenReady() callback async and added await initContainer() call
- Typecheck passes, lint passes

**Learnings for future iterations:**
- reflect-metadata must be imported BEFORE any other imports that use decorators
- TypeDI services are registered when their files are imported (the @Service() decorator executes)
- Dynamic import of service files ensures all decorated classes are registered with the container
- Container initialization should happen early in app lifecycle, before IPC handlers are registered
- The pattern mirrors the server-side IOC setup but simplified for Electron's single-process model
---

## Codebase Patterns
- Electron 项目使用 vite-plugin-electron 实现热重载开发
- TypeScript 配置使用 project references 分别配置 main/preload/renderer 进程
- 类型定义放在 src/types/ 目录，通过 import 在需要的地方引入
- IPC 通信使用 contextBridge 暴露 API，避免直接暴露 ipcRenderer
- LanceDB Node.js SDK (vectordb) 使用 `connect()` 连接数据库，`table.search([])` 查询数据
- IPC Router 模式：main 进程注册 `api:request` handler，将 HTTP-like 请求路由到本地服务方法
- LanceDB 限制：不支持添加/删除列、不支持表重命名（需复制数据实现）
- 本地存储使用 localStorage，键名格式：`mancedb_{feature}_{key}`
- Electron 环境检测使用 `isElectron()` 工具函数，基于 process.versions.electron 和 window.electronAPI
- Electron 单实例：使用 `app.requestSingleInstanceLock()` 和 `app.on('second-instance')` 处理多实例
- 窗口状态持久化：存储在 `app.getPath('userData')/window-state.json`
- 应用菜单：使用 `Menu.buildFromTemplate()` 和 `Menu.setApplicationMenu()`，macOS 有特殊菜单结构

---

# Ralph Progress Log
# Project: Electron Desktop Client for LanceDB Admin
# Branch: feat/electron-client
# Base Branch: main
# Started: 2026-02-16

## User Stories

[x] US-001: 创建 Electron 基础项目结构
[x] US-002: 集成 Web 应用到 Electron
[x] US-003: 实现 Web 项目 Electron 适配改造
[x] US-004: 实现本地文件系统访问
[x] US-005: 实现原生 LanceDB 连接模式
[x] US-006: 实现连接模式切换 UI
[x] US-007: 添加系统集成特性
[x] US-008: 实现自动更新检查
[x] US-009: 配置跨平台打包

## 2026-02-16 07:45 - US-001
- 创建 apps/client 目录，包含完整的 Electron 项目结构
- 配置 TypeScript：使用 project references 分别配置 main/preload/renderer
- 配置 Vite：使用 vite-plugin-electron 实现热重载
- 配置 ESLint：继承项目现有配置风格
- 添加开发脚本：pnpm dev 支持 hot reload
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- vite-plugin-electron 自动处理 main/preload 进程的构建和热重载
- contextBridge 是安全的 IPC 通信方式，需要在 preload 中定义类型并在 renderer 中引入
- Electron 的 types 需要单独配置，不能和 DOM types 混用（main 进程）
- 项目使用 pnpm workspace，新包需要运行 pnpm install 安装依赖
---

## 2026-02-16 08:30 - US-002
- 更新 web app vite.config.ts：支持 ELECTRON=true 环境变量，构建输出到 apps/client/dist/web
- 更新 Electron main 进程：开发模式加载 web dev server (localhost:5173)，生产模式加载构建产物
- 更新 client vite.config.ts：配置 VITE_DEV_SERVER_URL 传递给 main 进程
- 添加环境检测工具：apps/web/src/utils/environment.ts (isElectron, isBrowser, getPlatform 等)
- 路由适配：App.tsx 根据环境自动选择 HashRouter (Electron) 或 BrowserRouter (浏览器)
- 添加类型定义：apps/web/src/types/electron.d.ts 声明 window.electronAPI
- 添加构建脚本：client package.json 添加 build:web 和 build:electron 脚本
- 根 package.json 添加 dev:client 和 build:client 脚本
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- Electron 使用 file:// 协议加载本地文件时，需要使用 HashRouter 替代 BrowserRouter（History API 不支持 file 协议）
- vite-plugin-electron 通过 process.env.VITE_DEV_SERVER_URL 向 main 进程传递 dev server URL
- 使用 ELECTRON=true 环境变量控制 web app 的构建输出路径
- 环境检测通过多种方式：process.versions.electron, window.electronAPI, navigator.userAgent
- 开发流程：先启动 web dev server (localhost:5173)，然后启动 Electron 加载该 URL
---

## 2026-02-16 16:00 - US-003
- 创建统一 API 客户端：apps/web/src/utils/api-client.ts，支持 HTTP 和 IPC 两种模式
- 创建 IPC 请求工具：apps/web/src/utils/ipc-request.ts，用于 Electron 本地模式
- 更新 Electron preload 脚本：添加 invoke 方法支持 request-response 模式
- 更新 Electron 类型定义：添加 invoke 方法到 ElectronAPI 接口
- 迁移所有 API 文件：auth.ts, user.ts, connection.ts, connection-auth.ts, database.ts, table.ts, table-schema.ts, table-data.ts, query.ts
- 修复 environment.ts 类型问题：添加 Process 类型声明避免 TypeScript 错误
- 修复 tsconfig.renderer.json：调整 rootDir 以包含 types 目录
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- 统一 API 客户端设计：api-client.ts 自动检测环境并选择 HTTP 或 IPC 模式
- IPC 通信使用 invoke 模式：比 send/receive 更适合 request-response 场景
- TypeScript 类型兼容：使用 `object | Record<string, unknown>` 来接受更灵活的参数类型
- Electron 的 process 对象在 renderer 进程中需要类型声明
- 所有 API 函数现在通过 apiClient.{get,post,put,delete,patch} 调用，保持与原有 axios API 相同的返回格式 {code, data, message}
---

## 2026-02-16 18:00 - US-004
- 实现 IPC 通道 `dialog:openDirectory`：在 main 进程中添加文件夹选择对话框处理器
- 更新 preload 脚本：`openDirectory` 方法已存在，通过 `invoke` 调用 main 进程
- 修改 connection-form.tsx：为 Local Path 字段添加 Browse 按钮（仅在 Electron 环境显示）
- 添加 FolderOpenIcon 图标组件用于 Browse 按钮
- 更新帮助文本：Electron 环境下显示"Select a local LanceDB database folder"
- 错误处理：通过 try-catch 处理对话框调用异常，用户取消时返回 null

**Learnings for future iterations:**
- Electron 的 dialog.showOpenDialog 需要在 main 进程中通过 ipcMain.handle 暴露
- 使用 `properties: ['openDirectory']` 限制只能选择文件夹（不能选择文件）
- 通过 BrowserWindow.getAllWindows()[0] 获取主窗口作为对话框的父窗口
- 在 UI 中使用 `isElectron()` 检测环境，条件显示 Electron 特有功能
- 对话框的权限错误（如无法访问文件夹）由 Electron 自动处理并显示系统错误对话框
---

## 2026-02-16 20:00 - US-005
- 安装 LanceDB Node.js SDK (vectordb) 到 apps/client
- 创建 lancedb.service.ts：实现所有数据库操作
  - 连接管理：connectToDatabase, closeConnection, testConnection
  - 数据库信息：getDatabaseInfo, getTables
  - 表操作：getTableSchema, getTableData, deleteTable, renameTable
  - 数据操作：deleteRows, deleteRowById
  - 查询：executeQuery（支持基本 SELECT * FROM）
  - 列操作：addColumn, dropColumn（抛出错误 - LanceDB 不支持）
- 创建 ipc-router.ts：将 HTTP API 映射到 LanceDB 服务
  - 注册 `api:request` IPC handler 处理所有 API 请求
  - 路由表覆盖所有 web app API 端点
  - 本地模式 mock 认证响应（免登录）
  - 新增 IPC 通道：db:connect, db:disconnect, db:test
- 更新 preload/index.ts：添加新的 IPC 通道到 VALID_INVOKE_CHANNELS
- 更新 main/index.ts：在 app.whenReady 中注册 IPC handlers
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- LanceDB SDK 使用 `connect(uri)` 连接数据库，`table.search(vector)` 查询数据
- 非向量查询时使用 `table.search([])` 然后配合 `.filter()` 和 `.limit()`
- LanceDB 表结构基于 Apache Arrow，schema 包含字段名、类型、nullable 信息
- LanceDB 限制：不支持 ALTER TABLE（添加/删除列），不支持 RENAME TABLE
- IPC Router 模式让 web app 代码无需修改即可在 Electron 本地模式运行
- 使用 `void variable` 模式避免未使用参数警告（替代 underscore prefix）
---

## 2026-02-16 22:00 - US-006
- 创建启动模式选择页面：apps/web/src/pages/startup/startup-mode.tsx
  - 两种模式选择卡片：远程服务器连接 / 本地数据库打开
  - 远程模式：输入服务器 URL，测试连接后跳转到登录页
  - 本地模式：选择文件夹路径，直接连接后跳转到数据库浏览器
- 更新 App.tsx：添加 `/startup` 路由
- 更新 auth.tsx：Electron 环境下未选择模式时重定向到启动页
- 更新 electron.d.ts：添加 `invoke` 方法类型定义
- 持久化：使用 localStorage 保存选择的模式和配置
  - `mancedb_startup_mode`: 'remote' | 'local'
  - `mancedb_server_url`: 远程服务器地址
  - `mancedb_local_path`: 本地数据库路径
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- 启动页设计模式：检测无配置 -> 显示启动页 -> 选择模式 -> 保存配置 -> 跳转到对应流程
- 远程模式需要认证（跳转到 /auth），本地模式免认证（直接跳转数据库浏览器）
- 使用 `setAPIMode()` 动态切换 HTTP/IPC 模式
- IPC `db:test` 和 `db:connect` 通道已在 US-005 实现，本故事直接复用
- 本地存储键名统一使用 `mancedb_` 前缀避免冲突
---

## 2026-02-16 23:30 - US-007
- 创建应用菜单模块：apps/client/src/main/menu.ts
  - macOS 平台：应用菜单（About, Services, Hide, Quit）
  - 所有平台：File 菜单（New Connection, Open Local Database）
  - Edit 菜单（Undo, Redo, Cut, Copy, Paste, Select All）
  - View 菜单（Reload, Force Reload, Zoom, Fullscreen, DevTools）
  - Window 菜单（Minimize, Close）
  - Help 菜单（Learn More, Documentation）
- 创建窗口状态管理工具：apps/client/src/main/utils/window-state.ts
  - 保存/加载窗口大小、位置、最大化状态、全屏状态
  - 状态存储在 app.getPath('userData')/window-state.json
- 更新主进程：apps/client/src/main/index.ts
  - 添加单实例锁定：app.requestSingleInstanceLock()
  - 处理 second-instance 事件：聚焦原窗口
  - 集成应用菜单创建
  - 集成窗口状态恢复和保存
  - 添加窗口事件监听（resize, move, maximize, etc.）
- 添加图标资源：apps/client/public/logo.png, logo.svg
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- Electron 单实例模式：使用 requestSingleInstanceLock() 和 second-instance 事件
- 窗口状态持久化：使用 userData 目录存储 JSON 文件
- 菜单快捷键：使用 accelerator 字段定义键盘快捷键（CmdOrCtrl+N 等）
- macOS 特有菜单项：app 菜单、Speech 子菜单、window 菜单项
- 类型导入：使用 `type MenuItemConstructorOptions` 遵循 verbatimModuleSyntax
---

## 2026-02-17 00:15 - US-008
- 安装 electron-updater 依赖
- 创建自动更新模块：apps/client/src/main/updater.ts
  - initAutoUpdater(): 初始化自动更新，注册事件处理器
  - checkForUpdates(): 手动检查更新（用于菜单）
  - checkForUpdatesOnStartup(): 启动后 5 秒自动检查
- 更新主进程：集成自动更新初始化和启动检查
- 更新菜单：Help 菜单添加 "Check for Updates" 选项
- 开发模式处理：检测 VITE_DEV_SERVER_URL 时跳过更新检查并显示提示
- 对话框父窗口处理：使用条件判断处理窗口存在/不存在的情况
- 类型检查通过，lint 通过

**Learnings for future iterations:**
- electron-updater 需要在生产环境才能正常工作，开发模式需要特殊处理
- dialog.showMessageBox 有两个重载：带 window 参数和不带 window 参数
- 使用 `window ? dialog.showMessageBox(window, opts) : dialog.showMessageBox(opts)` 模式处理可选窗口
- autoUpdater 事件：checking-for-update, update-available, update-not-available, error, download-progress, update-downloaded
- autoUpdater.quitAndInstall() 会退出应用并安装更新
---

## 2026-02-16 08:30 - US-009
- Created electron-builder.yml with full cross-platform configuration
  - macOS: .dmg and .zip for x64 and arm64 architectures
  - Windows: .exe (NSIS) and .msi for x64 and ia32 architectures
  - Linux: .AppImage and .deb for x64 architecture
- Created build resources directory with all required assets:
  - icon.icns (macOS app icon with multiple sizes)
  - icon.ico (Windows app icon with multiple sizes)
  - icon.png + icons/ directory (Linux icon set)
  - entitlements.mac.plist (macOS code signing entitlements)
  - installer.nsh (Windows NSIS installer customizations)
- Updated package.json with build scripts:
  - `dist`: Build for current platform
  - `dist:all`: Build for all platforms (macOS, Windows, Linux)
  - `dist:mac`, `dist:win`, `dist:linux`: Platform-specific builds
  - `postinstall`: Install app dependencies for native modules
- Created GitHub Actions workflow (.github/workflows/build-client.yml):
  - Builds on macOS, Ubuntu, and Windows runners
  - Runs typecheck and lint before building
  - Uploads artifacts for each platform
  - Creates GitHub releases on version tags
- Updated .gitignore to allow build resources while ignoring build outputs
- Updated CLAUDE.md with build documentation and icon generation commands
- Type check and lint pass

**Learnings for future iterations:**
- electron-builder configuration uses `directories.output` for release artifacts location
- macOS code signing requires entitlements for file system access (user-selected files)
- Windows NSIS installer can be customized with .nsh scripts
- GitHub Actions secrets needed for code signing: CSC_LINK/CSC_KEY_PASSWORD (macOS), WIN_CSC_LINK/WIN_CSC_KEY_PASSWORD (Windows)
- Icon formats needed: .icns (macOS), .ico (Windows), .png set (Linux)
- The `build` directory name conflicts with common .gitignore patterns - need explicit exception
---

## 2026-02-16 16:10 - US-002
- 创建 packages/dto/src/database.dto.ts，导出 TableInfo 和 DatabaseInfo 接口
- 创建 packages/dto/src/table.dto.ts，导出 ColumnInfo, TableSchema, FilterCondition, TableDataResult 等接口
- 更新 packages/dto/src/index.ts，导出所有新的 DTO 类型
- 编译 packages/dto 成功，所有类型正确生成到 dist/index.d.ts
- 类型包含完整的 JSDoc 注释，便于 IDE 提示

**Learnings for future iterations:**
- DTO 包使用 rollup 构建，生成 CommonJS 和 ESM 两种格式
- 类型定义文件在 dist/types/ 目录，最终合并到 dist/index.d.ts
- 所有 DTO 接口使用可序列化的类型（适合 JSON 和 IPC 传输）
- 向量维度使用可选字段 vectorDimension?: number 标识
- 复用 server 中已有的类型定义作为基础，确保兼容性
---

## 2026-02-16 16:30 - US-003 (LanceDB Refactor)
- 创建 packages/lancedb-core/src/utils/filter-builder.ts
  - buildWhereClause: 从 FilterCondition[] 构建 LanceDB WHERE 子句
  - buildSingleFilter: 构建单个过滤条件
  - buildFilterString: buildWhereClause 的别名
  - escapeFilterValue: 转义字符串值中的单引号
  - buildIdFilter: 构建 ID 过滤条件
- 创建 packages/lancedb-core/src/utils/arrow-mapper.ts
  - mapArrowTypeToDisplayType: 将 Arrow 类型映射为显示类型
  - parseVectorType: 解析向量类型获取元素类型和维度
  - isVectorType: 检查是否为向量类型
  - getTypeByteSize: 获取类型的字节大小估算
  - mapDisplayTypeToArrowSql: 将显示类型映射为 Arrow SQL 类型
- 创建 packages/lancedb-core/src/utils/row-processor.ts
  - isVector: 检查值是否为向量（长度>10的数字数组）
  - processRow: 处理行数据，截取向量和二进制数据
  - processValue: 处理单个值
  - processRows: 批量处理多行
  - truncateVector: 截取向量显示（显示首尾部分）
  - getVectorStats: 获取向量统计信息
- 更新 utils/index.ts 统一导出所有工具函数
- 添加 @mancedb/dto 依赖到 package.json
- 修复 eslint.config.mjs 导入路径（添加 .js 扩展名）
- Typecheck passes

**Learnings for future iterations:**
- 工具函数使用纯函数设计，便于测试和复用
- 使用 JSDoc 注释提供完整的类型信息和示例
- filter-builder 需要处理字符串值的单引号转义（LanceDB SQL 语法）
- arrow-mapper 需要处理多种 Arrow 类型（fixed_size_list, list, dictionary, timestamp 等）
- row-processor 的 isVector 使用启发式检测（长度>10的数字数组）
- eslint.config.mjs 导入需要 .js 扩展名（ESM 要求）
---

## 2026-02-16 17:00 - US-004 (LanceDB Refactor)
- 创建 packages/lancedb-core/src/connection/connection-manager.ts
  - ConnectionManager 类使用 @Service() 装饰器，支持 TypeDI 依赖注入
  - connect(uri, options) 方法支持本地路径和 S3 URI
  - getConnection(uri) 返回缓存的连接，避免重复创建
  - disconnect(uri) 关闭特定连接并从缓存中移除
  - disconnectAll() 关闭所有连接
  - 支持 S3ConnectionConfig 配置（bucket, region, accessKey, secretKey, endpoint）
- 更新 packages/lancedb-core/src/connection/index.ts 导出 ConnectionManager
- 修复 rollup.config.js 使用 createRollupConfig 替代 defineConfig
- Typecheck passes, build passes

**Learnings for future iterations:**
- ConnectionManager 使用 Map<string, ConnectionEntry> 缓存连接，键为 URI
- S3 连接需要 storageOptions 配置：virtualHostedStyleRequest, conditionalPut, awsAccessKeyId 等
- LanceDB 的 Connection 对象需要显式调用 close() 释放资源
- 使用 TypeDI @Service() 装饰器实现单例模式，无需手动实现
- rollup.config.js 必须使用 createRollupConfig 并传入 input 和 packageDir
---

## 2026-02-16 17:30 - US-005
- 创建 packages/lancedb-core/src/schema/schema-manager.ts
  - SchemaManager 类使用 @Service() 装饰器，支持 TypeDI 依赖注入
  - getTableSchema(table, tableName) 方法解析 Arrow Schema 返回 TableSchema
  - parseField(field) 方法将 Arrow 字段解析为 ColumnInfo
  - getColumnInfo(table, columnName) 获取单个列信息
  - getColumnNames(table) 获取所有列名
  - hasColumn(table, columnName) 检查列是否存在
  - getVectorColumns(table) 获取所有向量列
  - estimateTableSize(rowCount, columns) 估算表大小
- 创建 packages/lancedb-core/src/schema/index.ts 导出 SchemaManager
- 复用 arrow-mapper.ts 中的工具函数进行类型映射
- Typecheck passes, build passes

**Learnings for future iterations:**
- LanceDB 的 table.schema() 返回 Promise<Schema>，包含 fields 数组
- 每个 field 有 name, type (有 toString() 方法), nullable 属性
- 使用 arrow-mapper.ts 中的 parseVectorType 检测向量类型并获取维度
- SchemaManager 专注于 schema 解析，不涉及连接管理（由 ConnectionManager 处理）
- Table 对象由调用方提供，保持 SchemaManager 的纯粹性
---

## 2026-02-17 09:00 - US-006
- 创建 packages/lancedb-core/src/table/table-manager.ts
  - TableManager 类使用 @Service() 装饰器，注入 ConnectionManager 和 SchemaManager
  - getTables(uri) 方法列出所有表，返回 TableInfo[] 包含行数和大小
  - getTableCount(uri) 获取表数量
  - tableExists(uri, tableName) 检查表是否存在
  - getTable(uri, tableName) 获取 Table 对象
  - createTable(uri, tableName, data, options) 创建新表，支持 overwrite/ignoreIfExists
  - createEmptyTable(uri, tableName, columns, options) 创建空表（带 schema）
  - deleteTable(uri, tableName) 删除表
  - renameTable(uri, oldName, newName) 重命名表（复制+删除实现）
  - copyTable(uri, sourceName, targetName, options) 复制表
  - getTableStats(uri, tableName) 获取表统计信息
  - clearTable(uri, tableName) 清空表数据
- 更新 packages/lancedb-core/src/table/index.ts 导出 TableManager
- Typecheck passes, build passes

**Learnings for future iterations:**
- TableManager 依赖 ConnectionManager 和 SchemaManager，通过构造函数注入
- LanceDB 不支持原生 rename，需要通过复制数据+删除旧表实现
- LanceDB 创建表时必须提供数据，createEmptyTable 使用单条样本数据 workaround
- table.query().limit(N).toArray() 是获取表数据的方式（N 需要足够大）
- 清空表通过删除+重建实现，保留原 schema 结构
---

## 2026-02-17 10:00 - US-007
- 创建 packages/lancedb-core/src/query/query-engine.ts
- 实现 QueryEngine 类，使用 @Service() 装饰器，注入 ConnectionManager 和 TableManager
- 实现 queryTable(params) 方法：
  - 支持分页（page, pageSize）、过滤（filters）
  - 使用 table.query().where().offset().limit() API
  - 使用 filter-builder.ts 的 buildWhereClause 构建 WHERE 条件
  - 使用 row-processor.ts 的 processRows 处理行数据（截取向量）
  - 返回 TableDataResult 格式结果（rows, totalCount, page, pageSize, totalPages）
- 实现 executeSql(uri, sql) 方法：
  - 解析 SQL 提取表名（FROM clause）和 WHERE 子句
  - 将 SQL WHERE 条件转换为 FilterCondition 数组
  - 执行查询并返回 TableDataResult
- 添加辅助方法：
  - getFilteredCount: 获取过滤后的行数
  - executeQuery: 执行分页查询
  - recordToObject: 将 LanceDB 记录转换为普通对象
  - parseSql: 解析 SQL SELECT 语句
  - sqlWhereToFilters: 将 SQL WHERE 转换为 FilterCondition
- 更新 packages/lancedb-core/src/query/index.ts 导出 QueryEngine
- Typecheck passes, build passes

**Learnings for future iterations:**
- LanceDB Query API 不支持 orderBy 排序，需要通过其他方式实现排序
- LanceDB Query API 支持 offset() 和 limit() 用于分页
- SQL 解析使用正则表达式，仅支持基本的 SELECT * FROM table WHERE conditions 格式
- processRows 会自动处理向量截断，避免大向量污染 UI
- 依赖注入通过构造函数使用 @Inject(() => ServiceClass) 语法
---

## 2026-02-17 10:15 - US-008
- 更新 packages/lancedb-core/src/index.ts，添加 schema 模块导出
- 导出所有公共类和类型：
  - ConnectionManager（连接管理器）
  - SchemaManager（Schema 管理器）
  - TableManager（表管理器）
  - QueryEngine（查询引擎）
- 导出所有工具函数：
  - filter-builder: buildWhereClause, buildSingleFilter, buildFilterString, escapeFilterValue, buildIdFilter
  - arrow-mapper: mapArrowTypeToDisplayType, parseVectorType, isVectorType, getTypeByteSize, mapDisplayTypeToArrowSql
  - row-processor: isVector, processRow, processValue, processRows, truncateVector, getVectorStats
- 导出类型：ConnectionOptions, S3ConnectionConfig, CreateTableOptions, QueryTableParams
- 运行 pnpm build 成功编译
- Typecheck passes

**Learnings for future iterations:**
- 主入口文件 index.ts 需要显式导出所有子模块（connection, schema, table, query, utils）
- 类型定义文件 dist/index.d.ts 会自动合并所有导出，包含完整的 JSDoc 注释
- 确保每个子模块都有 index.ts 文件统一导出，方便主入口批量导出
---

## 2026-02-16 16:30 - US-009
- Added @mancedb/lancedb-core dependency to apps/server package.json
- Updated apps/server/src/sources/lancedb.ts:
  - Injected ConnectionManager via TypeDI @Inject decorator
  - Refactored init() to use ConnectionManager.connect() for both local and S3 connections
  - Updated close() to use ConnectionManager.disconnectAll()
- Updated apps/server/src/services/database.service.ts:
  - Injected ConnectionManager and TableManager via TypeDI
  - Updated connectToDatabase() to use ConnectionManager with proper S3 config
  - Refactored getTables() to use TableManager.getTables()
  - Refactored getDatabaseInfo() to use TableManager.getTables()
  - Updated types to import TableInfo and DatabaseInfo from @mancedb/dto
  - Added helper method getConnectionUri() to build URI from connection config
- Typecheck passes, build passes

**Learnings for future iterations:**
- ConnectionManager from lancedb-core handles both local and S3 connections with proper storage options
- TableManager.getTables() returns TableInfo[] with rowCount and sizeBytes already populated
- TypeDI dependency injection uses @Inject(() => ServiceClass) syntax for constructor injection
- No duplicate utility functions found in server - they weren't previously extracted
- The eslint-plugin-turbo has a pre-existing issue unrelated to these changes
---

## 2026-02-17 11:00 - US-010
- Updated apps/server/src/services/table.service.ts:
  - Injected SchemaManager and QueryEngine via TypeDI @Inject decorator
  - Refactored getTableSchema() to use SchemaManager.getTableSchema()
  - Refactored getTableData() to use QueryEngine.queryTable()
  - Added helper method getConnectionUri() to build URI from connection config
  - Removed duplicate filter building logic (now handled by QueryEngine)
  - Removed duplicate row processing logic (now handled by QueryEngine)
- Updated apps/server/src/services/query.service.ts:
  - Injected QueryEngine via TypeDI @Inject decorator
  - Refactored executeQuery() to use QueryEngine.executeSql()
  - Removed duplicate SQL parsing logic (now handled by QueryEngine)
  - Removed duplicate connection management logic
- Typecheck passes, build passes

**Learnings for future iterations:**
- QueryEngine.queryTable() handles pagination, filtering, and row processing automatically
- QueryEngine.executeSql() parses SQL and executes queries using the same underlying logic
- SchemaManager.getTableSchema() provides standardized schema parsing across client and server
- Keep buildFilterString() in TableService for deleteRows() which uses filters directly with table.delete()
- URI-based approach (getConnectionUri) simplifies service methods by avoiding repeated connection handling
---

## Notes

